<?php

/** HOOKS ***************************************************************/

/**
 * Checks, saves and outputs cache for explicit BuddyPress widgets.
 *
 * @param array $instance Current widget arguments
 * @param object $widget_object Current widget class object
 * @param array $args Widget sidebar arguments
 * @return array|bool Array of current widget arguments if the widget does not
 *         match a BP widget we want to cache.  False for a BP widget that we
 *         have cached to bail out of WP's widget display sequence.
 */
function bp_widget_cache_display( $instance, $widget_object, $args ) {
	$break = false;
	foreach( (array) bp_widget_get_cache_classes() as $widget_class ) {
		if ( $widget_object instanceof $widget_class ) {
			$break = true;
			break;
		}
	}

	// Bail
	if ( false === $break || false === $instance ) {
		return $instance;
	}

	$timer_start = microtime( true );

	$transient_key = bp_widget_get_transient_key( get_class( $widget_object ) );

	$cache        = get_site_transient( $transient_key );
	$instance_key = bp_widget_get_instance_key( $widget_object, $instance, $args );

	if ( empty( $cache ) ) {
		$cache = array();
	}

	// cache widget output if not in existing cache
	if ( empty( $cache[$instance_key] ) ) {
		// start the buffer
		ob_start();

		// get the widget output
		$widget_object->widget( $args, $instance );
		$cache[$instance_key] = ob_get_contents();

		// end buffer
		ob_end_clean();

		// cache the contents
		set_site_transient( $transient_key, $cache, bp_widget_cache_ttl( $widget_object, $instance, $args ) );
	}

	// output the content
	printf(
		"%s <!-- #{$widget_object->id} generated by BP Widget Cache in %s seconds -->",
		$cache[$instance_key],
		number_format( microtime( true ) - $timer_start, 5 )
	);

	unset( $cache );

	// Return false to prevent further widget rendering
	return false;
}
add_filter( 'widget_display_callback', 'bp_widget_cache_display', 10, 3 );

/**
 * Remove old instance of a BP widget's cache when a widget is updated.
 *
 * This is done from the WP admin dashboard's "Appearance > Widgets" page.
 *
 * @param array $instance Current widget arguments
 * @param array $new_instance Current widget arguments
 * @param array $old_instance Old widget arguments
 * @param object $widget_object Current widget class object
 * @return array Current widget arguments
 */
function bp_widget_cache_update_settings( $instance, $new_instance, $old_instance, $widget_object ) {
	$break = false;
	foreach( (array) bp_widget_get_cache_classes() as $widget_class ) {
		if ( $widget_object instanceof $widget_class ) {
			$break = true;
			break;
		}
	}

	// Bail conditions
	if ( false === $break || false === $instance || $new_instance === $old_instance ) {
		return $instance;
	}

	// get transient key
	$transient_key = bp_widget_get_transient_key( get_class( $widget_object ) );

	// must get sidebar args based off the widget class
	$args = bp_widget_get_sidebar_args_for_widget( $widget_object );

	$cache = get_site_transient( $transient_key );
	$old_instance_key = bp_widget_get_instance_key( $widget_object, $old_instance, $args );

	// Remove cached content for old widget settings
	if ( isset( $cache[$old_instance_key] ) ) {
		unset( $cache[$old_instance_key] );
		set_site_transient( $transient_key, $cache, bp_widget_cache_ttl( $widget_object, $old_instance, $args ) );
	}

	// Remember to return the original!
	return $instance;
}
add_filter( 'widget_update_callback', 'bp_widget_cache_update_settings', 10, 4 );

/** CACHE INVALIDATION **************************************************/

/**
 * Helper function to invalidate all member widget caches.
 */
function bp_widget_cache_invalidate_member_widgets() {
	$widget_classes = apply_filters( 'bp_widget_cache_invalidate_member_widgets', array(
		'BP_Core_Members_Widget',
		'BP_Core_Whos_Online_Widget',
		'BP_Core_Recently_Active_Widget',
	) );

	foreach ( $widget_classes as $widget_class ) {
		delete_site_transient( bp_widget_get_transient_key( $widget_class ) );
	}
}
//add_action( 'bp_core_activated_user', 'bp_widget_cache_invalidate_member_widgets' );

/**
 * Add hook to invalidate recently active widget cache.
 *
 * Note: This relies on mirroring the last activity to user meta.  If BP
 * removes this in a future release, we'll need a new hook in
 * {@link bp_update_user_last_activity()}.
 *
 * @see bp_widget_cache_invalidate_on_user_last_activity()
 */
function bp_widget_cache_add_wp_head_hook() {
	if ( ! is_user_logged_in() ) {
		return;
	}

	add_action( 'update_user_meta', 'bp_widget_cache_invalidate_on_user_last_activity', 10, 3 );
}
add_action( 'wp_head', 'bp_widget_cache_add_wp_head_hook', 9 );

/**
 * Remove hook to invalidate recently active widget cache.
 *
 * Note: This relies on mirroring the last activity to user meta.  If BP
 * removes this in a future release, we'll need a new hook in
 * {@link bp_update_user_last_activity()}.
 *
 * @see bp_widget_cache_invalidate_on_user_last_activity()
 */
function bp_widget_cache_remove_wp_head_hook() {
	if ( ! is_user_logged_in() ) {
		return;
	}

	remove_action( 'update_user_meta', 'bp_widget_cache_invalidate_on_user_last_activity', 10, 3 );
}
add_action( 'wp_head', 'bp_widget_cache_remove_wp_head_hook', 20 );

/**
 * Invalidate the Recently Active member widget on a user's last activity.
 *
 * @param int $meta_id The meta ID
 * @param int $object_id The object ID
 * @param string $meta_key The meta key
 */
function bp_widget_cache_invalidate_on_user_last_activity( $meta_id, $object_id, $meta_key ) {
	if ( 'last_activity' !== $meta_key ) {
		return;
	}

	$widget_classes = apply_filters( 'bp_widget_cache_invalidate_user_last_activity', array(
		'BP_Core_Whos_Online_Widget',
		'BP_Core_Recently_Active_Widget',
	) );

	foreach ( $widget_classes as $widget_class ) {
		delete_site_transient( bp_widget_get_transient_key( $widget_class ) );
	}
}

/**
 * Invalidate various BuddyPress widgets by activity object.
 *
 * The activity component records various items from different components,
 * which is ideal to invalidate our widget caches when an activity item is
 * saved / deleted.
 *
 * Caveats with this approach is this requires the activity item to be
 * recorded.  Therefore, it's possible that if a plugin is blocking some items
 * from being recorded, that this approach won't work.  However, it's easy to
 * see at a glance what widget caches we're invalidating.
 *
 * @param array|object $activity Activity item
 */
function bp_widget_cache_invalidate_by_activity_object( $activity = '' ) {
	// during deletion, $activity can be an array; force it to an object
	$activity = (object) $activity;

	switch( $activity->type ) {
		case 'new_blog_post' :
		case 'new_groupblog_post' :
			delete_site_transient( bp_widget_get_transient_key( 'BP_Blogs_Recent_Posts_Widget' ) );
			break;

		case 'created_group' :
			delete_site_transient( bp_widget_get_transient_key( 'BP_Groups_Widget' ) );
			break;

		case 'new_member' :
			bp_widget_cache_invalidate_member_widgets();
			break;

		case 'friendship_created' :
			// this deletes all friend widget cache instances
			// @todo remove widgets only for the initiator and friend user IDs if possible
			delete_site_transient( bp_widget_get_transient_key( 'BP_Core_Friends_Widget' ) );
			break;

		default :
			break;
	}
}
add_action( 'bp_activity_after_save', 'bp_widget_cache_invalidate_by_activity_object' );
add_action( 'bp_activity_delete',     'bp_widget_cache_invalidate_by_activity_object' );

/**
 * Invalidate the Groups widget on a group's last activity update.
 *
 * @param int $meta_id The meta ID
 * @param int $object_id The object ID
 * @param string $meta_key The meta key
 */
function bp_widget_cache_invalidate_on_group_last_activity( $meta_id, $object_id, $meta_key ) {
	if ( 'last_activity' === $meta_key ) {
		delete_site_transient( bp_widget_get_transient_key( 'BP_Groups_Widget' ) );
	}
}
add_action( 'update_group_meta', 'bp_widget_cache_invalidate_on_group_last_activity', 10, 3 );

/**
 * Invalidate the Groups widget when a group is deleted.
 *
 * @param BP_Groups_Group $group The group object
 */
function bp_widget_cache_invalidate_on_group_delete( $group ) {
	delete_site_transient( bp_widget_get_transient_key( 'BP_Groups_Widget' ) );
}
add_action( 'bp_groups_delete_group', 'bp_widget_cache_invalidate_on_group_delete' );

/**
 * Clears all BP widget caches.
 *
 * Currently, this is done when:
 *  - A theme is changed
 *  - This plugin is deactivated
 *  - When a user is marked as a spammer / unmarked as a spammer
 *  - When a user is deleted
 */
function bp_widget_cache_invalidate_all() {
	foreach( (array) bp_widget_get_cache_classes() as $widget_class ) {
		delete_site_transient( bp_widget_get_transient_key( $widget_class ) );
	}
}
add_action( 'switch_theme',                   'bp_widget_cache_invalidate_all' );
add_action( 'bp_core_process_spammer_status', 'bp_widget_cache_invalidate_all' );
add_action( 'bp_core_deleted_account',        'bp_widget_cache_invalidate_all' );

/**
 * Invalidate widget cache when a widget is deleted.
 */
function bp_widget_cache_invalidate_on_widget_delete() {
	if ( ! bp_is_post_request() || ! isset( $_POST['delete_widget'] ) ) {
		return;
	}

	if ( 1 !== (int) $_POST['delete_widget'] ) {
		return;
	}

	// Get the widget ID
	$widget_id = $_POST['widget-id'];

	// Grab the widget object
	global $wp_registered_widgets;
	$widget_object = ! empty( $wp_registered_widgets[$widget_id]['callback'][0] ) ? $wp_registered_widgets[$widget_id]['callback'][0] : false;

	if ( false === $widget_object ) {
		return;
	}

	// get widget instance from the widget's DB option
	$instance = get_option( $widget_object->option_name );
	$instance = ! empty( $instance[$widget_object->number] ) ? $instance[$widget_object->number] : false;

	if ( false === $instance ) {
		return;
	}

	// get transient key
	$transient_key = bp_widget_get_transient_key( get_class( $widget_object ) );

	// must get sidebar args based off the widget class
	$args = bp_widget_get_sidebar_args_for_widget( $widget_object );

	$cache = get_site_transient( $transient_key );
	$instance_key = bp_widget_get_instance_key( $widget_object, $instance, $args );

	// Remove cached content for old widget settings
	if ( isset( $cache[$instance_key] ) ) {
		unset( $cache[$instance_key] );
		set_site_transient( $transient_key, $cache, bp_widget_cache_ttl( $widget_object, $instance, $args ) );
	}
}
add_action( 'sidebar_admin_setup', 'bp_widget_cache_invalidate_on_widget_delete' );

/** CUSTOM TTL **********************************************************/

/**
 * Add custom TTL for the Recently Active members widget.
 *
 * The Recently Active widget queries users that were active during the last
 * 15 minutes by default.  So we should make sure our transient cache for this
 * widget should be 14 minutes to be safe.
 */
function bp_widget_ttl_recently_active( $retval, $widget_object ) {
	if ( $widget_object instanceof BP_Core_Recently_Active_Widget ) {
		$retval = 60 * apply_filters( 'bp_user_query_online_interval', 15 ) - 60;

		if ( $retval < 1 ) {
			$retval = 60 * 10;
		}
	}

	return (int) $retval;
}
add_filter( 'bp_widget_cache_ttl', 'bp_widget_ttl_recently_active', 10, 2 );

/** UTILITY *************************************************************/

/**
 * Get a list of widget class names to cache widget contents for.
 *
 * Plugin devs can register their widget class here for BP Widget Cache to
 * handle caching.
 *
 * @return array
 */
function bp_widget_get_cache_classes() {
	return apply_filters( 'bp_widget_get_cache_classes', array(
		'BP_Core_Members_Widget',
		'BP_Core_Whos_Online_Widget',
		'BP_Core_Recently_Active_Widget',
		'BP_Groups_Widget',
		'BP_Blogs_Recent_Posts_Widget',
		'BP_Core_Friends_Widget',
	) );
}

/**
 * Return the transient key for a BP widget.
 *
 * The transient key is derived from the class name of the widget class.
 *
 * @param string $class_name The class name the widget uses.
 */
function bp_widget_get_transient_key( $class_name = '' ) {
	$class_name = strtolower( $class_name );

	// as per WP docs, transient keys can only be 40 characters in length
	return substr( "bpwc_{$class_name}", 0, 40 );
}

/**
 * Return the instance key for a BP widget.
 *
 * When a widget's cache is fetched, we query WP for our transient.  The
 * transient is an array holding all different outputs for this widget.  Each
 * output is added as an item in the array.  To fetch a specific output of the
 * widget, we need to know the instance key.  This is what this function does.
 *
 * @param object $widget_object Current widget class object
 * @param array $instance Current widget arguments
 * @param array|bool $args Widget sidebar arguments.
 * @return string
 */
function bp_widget_get_instance_key( $widget_object, $instance, $args = array() ) {
	$r = array(
		$instance,
		$args,
	);

	// friends widget output is variable based on the displayed user's page
	// so we need to generate an instance key based off the user ID
	if ( $widget_object instanceof BP_Core_Friends_Widget ) {
		if ( bp_displayed_user_id() ) {
			$r[] = bp_displayed_user_id();
		}
	}

	return apply_filters( 'bp_widget_get_instance_key', md5( serialize( $r ) ), $r, $widget_object, $instance, $args );
}

/**
 * Get TTL for a cached BuddyPress widget.
 *
 * Default TTL is 12 hours.  Use filter to override for specific widgets.
 *
 * @param object $widget_object Current widget class object
 * @param array $instance Current widget arguments
 * @param array Widget sidebar arguments.
 * @return int
 */
function bp_widget_cache_ttl( $widget_object, $instance, $args = array() ) {
	return apply_filters( 'bp_widget_cache_ttl', 60 * 60 * 12, $widget_object, $instance, $args );
}

/**
 * Get the sidebar arguments for a widget.
 *
 * This mirrors the exact sidebar arguments for a widget that is generated in
 * {@link dynamic_sidebar()} during frontend widget rendering.
 *
 * @param object $widget_object Current widget class object
 * @return array|bool Array of sidebar arguments for the widget. False
 *         on failure.
 */
function bp_widget_get_sidebar_args_for_widget( $widget_object ) {
	// get all active sidebars
	$active_sidebars = array_filter( wp_get_sidebars_widgets() );
	unset( $active_sidebars['wp_inactive_widgets'] );

	// loop through sidebars and try to find our widget
	$sidebar_id = false;
	foreach( $active_sidebars as $sidebar => $widgets ) {
		if ( false !== array_search( $widget_object->id, $widgets ) ) {
			$sidebar_id = $sidebar;
			break;
		}
	}

	// couldn't find it, so bail
	if ( false === $sidebar_id ) {
		return false;
	}

	// generate sidebar args with widget details to emulate arguments in
	// dynamic_sidebar()
	global $wp_registered_sidebars;
	$sidebar = $wp_registered_sidebars[$sidebar_id];
	$sidebar['widget_id']     = $widget_object->id;
	$sidebar['widget_name']   = $widget_object->name;
	$sidebar['before_widget'] = sprintf( $sidebar['before_widget'], $widget_object->id, $widget_object->widget_options['classname'] );
	return $sidebar;
}
